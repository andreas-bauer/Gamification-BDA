---
title: "Gamification BDA"
execute:
  echo: false
---

## Introduction

Software testing is an integral part of software development.
Developers incorporate tests from low-level unit tests to high-level system tests and GUI-based tests.
GUI-based tests can verify a system's behavior through interactions with its GUI the same way a user would.
One approach to increase the engagement and motivation of people performing a task is Gamification, where elements originated in games are applied in a non-gaming context.
In the context of exploratory GUI-based testing, Gamification could improve testers' engagement and therefore improve the outcome of test activities.

Coppola et al. [1] conducted an experiment with 144 participants to investigate how Gamification would impact the effectiveness and efficiency of exploratory GUI testing.

In this project, I perform a (re-)analysis of the impacts of Gamification for exploratory GUI testing using Bayesian Data Analysis (BDA).
Input for this analysis is the [replication package](https://figshare.com/projects/GamificationReplicationPackage/127202) from the experiment [1].

## Directed Acyclic Graph (DAG)

A DAG helps us to understand the relationships between the different variables visually.

- **G**: Gamification approach was used; value = {true, false}
- **EJ**: Experience in Java; value = {"<1 year", "1-3 years", ">3 years"}
- **EW**: Experience in web development; value = {"<1 year", "1-3 years", ">3 years"}
- **ET**: Experience in software testing; value = {"<1 year", "1-3 years", ">3 years"}
- **W**: Inspected widgets
- **B**: Identified bugs
- **COV**: Test coverage
- **EF**: Effectiveness of exploratory testing
- **AW**: Average number of widgets on a page

```{r}
suppressPackageStartupMessages(library(dagitty))
suppressPackageStartupMessages(library(rethinking))
dag <- dagitty("dag {
G -> W
G -> B
EJ -> W
EJ -> B
EW -> W
EW -> B
ET -> W
ET -> B
W -> COV
B -> COV
AW -> COV
COV -> EF
}")
drawdag(dag)
```

Assumptions:

- G -\> W: Using Gamification encourage testers to inspect more widgets
- G -\> B: Using Gamification encourage testers to identify more bugs
- EJ -\> W: Experience in the used programming language will improve the inspection rate of widgets
- EJ -\> B: Experience in the used programming will identify more bugs
- EW -\> W: Experience in the technology of the SUT improves the inspection rate of widgets
- EW -\> B: Experience in the technology of the SUT improves the identification of bugs
- ET -\> W: Experience in software testing improves the inspection rate of widgets
- ET -\> B: Experience in software testing improves the identification of bugs
- W -\> COV: More inspected widgets increase the test coverage
- B -\> COV: More identified bugs increase the test coverage
- AW -\> COV: Average number of widgets on a page influence the test coverage of exploratory tests
- COV -\> EF: More test coverage improves the effectiveness of exploratory tests

### Building blocks

A causal DAG is always built using one or more of the four types of relations: Fork, Pipe, Collider, and Descendant.

**Fork**: In a fork relationship, a variable (G) is the cause of B and W, e.g., `B <- G -> W`. Here B and W stay independent

**Pipe**: In a pipe, variables influence the next element in the pipe, e.g., `B -> COV -> EF`. B influences COV, which influences EF. Conditioning on COV would block the information flow between B and EF.

**Collider**: In this DAG, an example of a collider is the `EJ -> W <- EW`.
A relationship between EF and WE only appears if you condition on W; otherwise, there will be no association between EJ and WE.

**Descendent**: The DAG consists of multiple descendent relationships, e.g., `AW -> COV <- B; COV -> EF`.
A descendent (EF) is influenced by another variable (COV).

## Import data from the replication package

Load raw data from replication package.

```{r}
demographicRaw <- read.csv(file = 'data/demographic.csv', header = TRUE, sep = ';')
withGameRaw <- read.csv(file = 'data/gamified_sessions.csv', header = TRUE, sep = ';')
withoutGameRaw <- read.csv(file = 'data/non_gamified_sessions.csv', header = TRUE, sep = ';')
```

Cleanup demographic data by replacing string representations of the experience levels with categorical numbers (1,2, and 3). 
Further, incomplete rows are removed
```{r}
demographic <- subset(demographicRaw, select = c(Group, Students.ID, expertise.in.java, expertise.in.sw.testing, expertise.in.web.app.development))

# remove incomplete rows
demographic <- demographic[complete.cases(demographic),]

colnames(demographic)[1] = "group"
colnames(demographic)[2] = "studentId"
colnames(demographic)[3] = "expJava"
colnames(demographic)[4] = "expTesting"
colnames(demographic)[5] = "expWeb"

expLessThan1Year = 1
expBetween1and3Years = 2
expMoreThan3Years = 3 

expAsNumeric <- Vectorize(vectorize.args = "expLevel", FUN = function(expLevel) {
  experience = tolower(expLevel)
  result = switch(
    experience,
    "less than one year"=expLessThan1Year,
    "between one year and three years"=expBetween1and3Years,
    "more than three years"=expMoreThan3Years,
    0
  )
})

# transform strings to numerical values
demographic[3:5] <- lapply(demographic[3:5], expAsNumeric)

# transform numerical values to categorical values
demographic[3:5] <- lapply(demographic[3:5], factor)
```


## References

[1] Coppola, R., Fulcini, T., Ardito, L., Torchiano, M. & AlÃ©groth, E., Gamification: the next Silver Bullet for Exploratory GUI Testing? (in revision)

[2] McElreath, R. (2020). Statistical rethinking: A Bayesian course with examples in R and Stan.

